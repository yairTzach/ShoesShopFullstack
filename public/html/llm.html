<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="../css/main.css"> <!-- path to the external CSS file -->
    <link rel="stylesheet" href="../css/readme.css"> <!-- path to the readme.css file for styling -->
    <style>
        .content-card {
            max-width: 800px; /* Set max width to fit within the frame */
            margin: 0 auto; /* Center the content-card */
            overflow-x: auto; /* Add horizontal scroll if needed */
            word-wrap: break-word; /* Ensure long text wraps within the container */
        }

        pre code {
            white-space: pre-wrap; /* Ensure code wraps within the container */
        }
    </style>
</head>
<body>

    <!-- Navbar -->
    <div id="header">
        <div id="cartIcon" class="fas fa-shopping-cart">
            <div id="cartCount">0</div>
        </div>
        <!-- Profile, Logout, Readme, and LLM links -->
        <i class="fas fa-shoe-prints navbar-icon"></i>
        <a href="/html/profile.html" id="profileButton" class="header-link">Profile</a>
        <i class="fas fa-shoe-prints navbar-icon"></i>
        <a href="/logout" id="logoutButton" class="header-link">Logout</a>
        <i class="fas fa-shoe-prints navbar-icon"></i>
        <a href="/html/readme.html" class="header-link">Readme</a>
        <h1 id="title">LLM</h1>
        <div id="navMenu">
            <a href="/html/main.html" id="homeButton" class="header-link">Home</a>
            <i class="fas fa-shoe-prints navbar-icon"></i>
            <a href="/html/publicReviews.html" id="Reviews" class="header-link">Reviews</a>
            <i class="fas fa-shoe-prints navbar-icon"></i>
            <a href="/html/purchaseHistory.html" id="purchaseHistoryIcon" class="header-link">Purchase History</a>
        </div>
    </div>

    <!-- Cart Container -->
    <div id="cartContainer" style="display: none;"> <!-- Initially hidden -->
        <h2>Shopping Cart</h2>
        <div id="cartItems"></div>
        <div id="cartTotal"></div>
        <a href="/html/cart.html" id="viewCartButton" class="proceed-button">View Cart</a>
    </div>

    <!-- Admin Buttons (Visible only to admins) -->
    <div id="adminButtons" style="display: none; justify-content: center; gap: 10px; margin-top: 20px;">
        <button id="adminManagementButton" class="admin-management-button">Admin Management</button>
        <button id="activityLogButton" class="admin-management-button">Activity Log</button>
    </div>

    <div class="content">

        <div class="content-card" style="background-color: #333; color: white; padding: 20px;">
            <h1>LLM Content</h1>
            <h2>Place your LLM text here : </h2>
            <div class="section">
                <h3>Utilization of Large Language Models (LLMs) in Our Project</h3>
                <p>During our project, we leveraged large language models (LLMs) like ChatGPT to enhance both productivity and understanding across various tasks. Here’s how we made use of these models:</p>
            </div>
        
            <div class="section">
                <h2>Code Documentation and Commenting</h2>
                <p>We utilized the LLM to assist in writing clear and comprehensive code comments. This ensured that our code was well-documented, making it easier to follow and understand.</p>
            </div>
        
            <div class="separator"></div>
        
            <div class="section">
                <h2>Learning and Skill Development</h2>
                <p>The LLM served as a valuable learning tool. We employed it to study and grasp a wide range of topics relevant to our project, including:</p>
                <ul>
                    <li>Working with cookies</li>
                    <li>Managing databases</li>
                    <li>Other key concepts</li>
                </ul>
                <p>This approach accelerated our learning and broadened our knowledge base.</p>
            </div>
        
            <div class="separator"></div>
        
            <div class="section">
                <h2>Code Generation and Development Efficiency</h2>
                <p>To boost productivity, we provided the LLM with the main ideas and functionalities we wanted to implement. The model generated code snippets based on our inputs, allowing us to:</p>
                <ul>
                    <li>Focus on refining the logic</li>
                    <li>Structure our application effectively</li>
                </ul>
                <p>This method helped us speed up the development process while maintaining control over the final implementation.</p>
            </div>
        
            <div class="separator"></div>
        
            <div class="section">
                <h2>Overall Impact</h2>
                <p>Integrating the LLM into our workflow allowed us to blend our own expertise and creativity with the capabilities of AI. As a result, we achieved more efficient and robust solutions for our project.</p>
            </div>    
            
            ___________________________________________________________________________

            
            <pre><code>
                function renderProducts(products) {
                    const productContainer = document.getElementById('productContainer');
                    productContainer.innerHTML = ''; // Clear previous results
                    products.forEach(product => {
                        console.log('Rendering product:', product); // Log each product being rendered
                        const productDiv = document.createElement('div');
                        productDiv.className = 'product';
                        productDiv.innerHTML = `
                            &lt;div class="image-container"&gt;
                            &lt;/div&gt;
                            &lt;h3&gt;${product.brand} - ${product.model}&lt;/h3&gt;
                            &lt;p&gt;${product.description}&lt;/p&gt;
                            &lt;p&gt;Price: $${product.price}&lt;/p&gt;
                            &lt;select class="size-select" data-id="${product._id}"&gt;
                                ${product.sizes.map(size => `&lt;option value="${size}"&gt;${size}&lt;/option&gt;`).join('')}
                            &lt;/select&gt;
                            &lt;div class="rating-display"&gt;
                                Rating: ${product.averageRating ? product.averageRating.toFixed(1) + ' ☆' : 'No ratings yet'}
                            &lt;/div&gt;
                            ${product.averageRating ? `&lt;a href="/all-reviews.html?productId=${product._id}" class="view-reviews-link"&gt;View Detailed Reviews&lt;/a&gt;` : ''}
                            &lt;button class="add-to-cart-button" data-id="${product._id}"&gt;Add to Cart&lt;/button&gt;
                        `;
                        productContainer.appendChild(productDiv);
                    });
                }

                body {
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    text-align: center;
                    margin: 0;
                    padding: 20px;
                    background: linear-gradient(135deg, #f4f4f9, #e6e6fa);
                    color: #333;
                }
                
                h1 {
                    font-size: 36px;
                    color: #333;
                    margin-bottom: 30px;
                    text-transform: uppercase;
                    letter-spacing: 2px;
                    background: -webkit-linear-gradient(#5c67f2, #007BFF);
                    -webkit-background-clip: text;
                    -webkit-text-fill-color: transparent;
                }
                
                .shoe-image {
                    max-width: 300px;
                    width: 100%;
                    height: auto;
                    margin-bottom: 30px;
                    border-radius: 15px;
                    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
                    transition: transform 0.3s ease, box-shadow 0.3s ease;
                }
                
                .shoe-image:hover {
                    transform: scale(1.05);
                    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.3);
                }
                
                .stars {
                    font-size: 64px;
                    color: #f4c10f;
                    display: inline-block;
                    position: relative;
                    margin-top: 20px;
                }
                
                .star {
                    display: inline-block;
                    position: relative;
                    font-size: 64px;
                    color: #f4c10f;
                }
                
                .star.full i {
                    color: #f4c10f; /* Full star color */
                }
                
                .star.empty i {
                    color: #ddd; /* Empty star color */
                }
                
                .star.partial {
                    position: relative;
                }
                
                .star.partial .partial-fill {
                    position: absolute;
                    overflow: hidden;
                    color: #f4c10f;
                    z-index: 1;
                }
                
                .star.partial .empty-fill {
                    color: #ddd;
                }
                
                .rating-text {
                    font-size: 32px;
                    margin-top: 20px;
                    color: #555;
                    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
                }
                
                .return-button {
                    padding: 15px 40px;
                    font-size: 24px;
                    color: white;
                    background-color: #007BFF;
                    border: none;
                    border-radius: 50px;
                    cursor: pointer;
                    margin-top: 30px;
                    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
                    transition: background-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
                }
                
                .return-button:hover {
                    background-color: #0056b3;
                    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
                    transform: translateY(-3px);
                }
                
                <div class="content-card" style="background-color: #333; color: white; padding: 20px;">
                    <h2>LLM Content</h2>
                    <p>Place your LLM text here.</p>
                    <pre><code>
                        function renderProducts(products) {
                            const productContainer = document.getElementById('productContainer');
                            productContainer.innerHTML = ''; // Clear previous results
                            products.forEach(product => {
                                console.log('Rendering product:', product); // Log each product being rendered
                                const productDiv = document.createElement('div');
                                productDiv.className = 'product';
                                productDiv.innerHTML = `
                                    &lt;div class="image-container"&gt;
                                    &lt;/div&gt;
                                    &lt;h3&gt;${product.brand} - ${product.model}&lt;/h3&gt;
                                    &lt;p&gt;${product.description}&lt;/p&gt;
                                    &lt;p&gt;Price: $${product.price}&lt;/p&gt;
                                    &lt;select class="size-select" data-id="${product._id}"&gt;
                                        ${product.sizes.map(size => `&lt;option value="${size}"&gt;${size}&lt;/option&gt;`).join('')}
                                    &lt;/select&gt;
                                    &lt;div class="rating-display"&gt;
                                        Rating: ${product.averageRating ? product.averageRating.toFixed(1) + ' ☆' : 'No ratings yet'}
                                    &lt;/div&gt;
                                    ${product.averageRating ? `&lt;a href="/all-reviews.html?productId=${product._id}" class="view-reviews-link"&gt;View Detailed Reviews&lt;/a&gt;` : ''}
                                    &lt;button class="add-to-cart-button" data-id="${product._id}"&gt;Add to Cart&lt;/button&gt;
                                `;
                                productContainer.appendChild(productDiv);
                            });
                        }


                        const saveUserToMongoDB = async (user) => {
                            try {
                                const savedUser = await User.findByIdAndUpdate(user._id, user, { new: true, upsert: true });
                                return savedUser;
                            } catch (error) {
                                if (error.code === 11000) {
                                    // Handle duplicate key error (e.g., email already exists)
                                    throw new Error('Email is already in use by another account');
                                }
                                console.error('Error saving user to MongoDB:', error);
                                throw error;
                            }
                        };
                            
                        


                        const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
    username: {
        type: String,
        required: true,
        unique: true
    },
    email: {
        type: String,
        required: true,
        unique: true, // Ensure the email field is unique
        lowercase: true
    },
    password: {
        type: String,
        required: true
    },
    // Other fields...
});

const User = mongoose.model('User', userSchema);

module.exports = User;



const express = require('express');
const User = require('../models/User'); // Adjust the path as needed
const profileRouter = express.Router();

profileRouter.post('/api/update-profile', async (req, res) => {
    try {
        const { userId } = req.cookies; // Assume the userId is stored in a cookie
        const { username, newEmail } = req.body;

        if (!userId) {
            return res.status(400).json({ message: 'User not authenticated' });
        }

        // Check if the new email is already used by another user
        const existingUser = await User.findOne({ email: newEmail.toLowerCase() });

        if (existingUser && existingUser._id.toString() !== userId) {
            return res.status(400).json({ message: 'Email is already in use by another account' });
        }

        // Update the user's email
        const updatedUser = await User.findByIdAndUpdate(userId, { email: newEmail.toLowerCase() }, { new: true });

        if (!updatedUser) {
            return res.status(404).json({ message: 'User not found' });
        }

        res.status(200).json({ message: 'Profile updated successfully', user: updatedUser });
    } catch (error) {
        console.error('Error updating profile:', error);
        res.status(500).json({ message: 'Internal server error' });
    }
});

module.exports = profileRouter;


router.get('/cart', async (req, res) => {
    const { userId, username } = req.cookies;

    // Check if user is logged in
    if (!userId || !username) {
        // Redirect to the main page if not logged in
        return res.redirect('/');
    }

    try {
        const user = await findUserById(userId);
        if (!user || user.username !== username) {
            // Redirect to the main page if the user is not found or the username does not match
            return res.redirect('/');
        }

        // Fetch and populate the cart data
        const populatedCart = await populateCartData(user.cart);
        res.render('cart', { cart: populatedCart });
    } catch (error) {
        console.error('Error fetching user data or cart:', error);
        // Redirect to the main page in case of any error
        return res.redirect('/');
    }
});

fetch('/api/purchase-history')
    .then(response => {
        if (response.status === 401) {
            window.location.href = '/login'; // Redirect to login if unauthorized
        } else if (!response.ok) {
            throw new Error('Failed to fetch purchase history');
        }
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('application/json')) {
            return response.json(); // Parse JSON if it’s a JSON response
        } else {
            throw new Error('Unexpected content type');
        }
    })
    .then(data => {
        if (data) {
            // Render the purchase history on the page
            // Your existing code to handle the data
        }
    })
    .catch(error => {
        console.error('Error fetching purchase history:', error);
        document.getElementById('purchaseHistory').innerHTML = '<p>Error loading purchase history.</p>';
    });
___________________________________________________________________________
const express = require('express');
const {
    findUserById,
    saveUser,
    updateOrAddToCart,
    removeFromCart,
    populatePurchases
} = require('../utils/persist'); 

const router = express.Router();

async function isAuthorized(req, res, next) {
    const { userId, username } = req.cookies;
    if (userId && username) {
        const user = await findUserById(userId);
        if (user && user.username === username) {
            req.user = user;
            return next();
        }
    }
    res.status(401).json({ message: 'Unauthorized' });
}

router.post('/api/cart/update', isAuthorized, async (req, res) => {
    try {
        const { productId, size, quantity } = req.body;
        const user = req.user;

        const result = await updateOrAddToCart(user, productId, size, quantity);

        if (!result.success) {
            return res.status(400).json({ success: false, message: result.message });
        }

        await saveUser(user);
        res.json({ success: true, message: 'Cart updated successfully', cart: result.cart });
    } catch (error) {
        console.error('Cart update error:', error);
        res.status(500).json({ success: false, message: 'Failed to update cart' });
    }
});

router.post('/api/cart/add', isAuthorized, async (req, res) => {
    try {
        const { productId, size, quantity } = req.body;
        const user = req.user;

        const result = await updateOrAddToCart(user, productId, size, quantity);

        if (!result.success) {
            return res.status(400).json({ success: false, message: result.message });
        }

        const currentActivity = { 
            type: 'add-to-cart', 
            datetime: new Date().toISOString(), 
            username: user.username 
        };
        user.activityLog.push(currentActivity);

        await saveUser(user);

        res.status(200).json({ success: true, message: 'Product added to cart', cart: result.cart });
    } catch (error) {
        console.error('Error updating cart:', error);
        res.status(500).json({ success: false, message: 'Failed to update cart' });
    }
});

router.post('/api/cart/remove', isAuthorized, async (req, res) => {
    try {
        const { productId, size } = req.body;
        const user = req.user;

        const updatedCart = removeFromCart(user, productId, size);
        await saveUser(user);

        res.status(200).json({ success: true, cart: updatedCart });
    } catch (error) {
        console.error('Error removing item from cart:', error);
        res.status(500).json({ success: false, message: 'Failed to update cart' });
    }
});

router.get('/cart', async (req, res) => {
    const user = await findUserByUsername(req.cookies.username); // Fetch user data

    if (user && user.cart) {
        const populatedCart = await populateCartData(user.cart);
        res.render('cart', { cart: populatedCart });
    } else {
        res.render('cart', { cart: [] });
    }
});

router.post('/api/cart/purchase', isAuthorized, async (req, res) => {
    try {
        const user = req.user;

        const populatedPurchases = await populatePurchases(user.cart);

        user.purchaseHistory = user.purchaseHistory.concat(populatedPurchases);

        user.cart = [];

        await saveUser(user);

        res.cookie('purchaseCompleted', 'true', { httpOnly: true, maxAge: 60000 }); // Set a cookie valid for 1 minute

        res.status(200).json({ success: true, message: 'Purchase completed successfully', purchaseHistory: user.purchaseHistory });
    } catch (error) {
        console.error('Error finalizing purchase:', error);
        res.status(500).json({ success: false, message: 'Failed to complete purchase' });
    }
});

module.exports = router;
___________________________________________________________________________
const express = require('express');
const {
    findUserById,
    saveUser,
    updateOrAddToCart,
    removeFromCart,
    populatePurchases
} = require('../utils/persist'); 

const router = express.Router();

async function isAuthorized(req, res, next) {
    const { userId, username } = req.cookies;
    if (userId && username) {
        const user = await findUserById(userId);
        if (user && user.username === username) {
            req.user = user;
            return next();
        }
    }
    res.status(401).json({ message: 'Unauthorized' });
}

router.post('/api/cart/update', isAuthorized, async (req, res) => {
    try {
        const { productId, size, quantity } = req.body;
        const user = req.user;

        const result = await updateOrAddToCart(user, productId, size, quantity);

        if (!result.success) {
            return res.status(400).json({ success: false, message: result.message });
        }

        await saveUser(user);
        res.json({ success: true, message: 'Cart updated successfully', cart: result.cart });
    } catch (error) {
        console.error('Cart update error:', error);
        res.status(500).json({ success: false, message: 'Failed to update cart' });
    }
});

router.post('/api/cart/add', isAuthorized, async (req, res) => {
    try {
        const { productId, size, quantity } = req.body;
        const user = req.user;

        const result = await updateOrAddToCart(user, productId, size, quantity);

        if (!result.success) {
            return res.status(400).json({ success: false, message: result.message });
        }

        const currentActivity = { 
            type: 'add-to-cart', 
            datetime: new Date().toISOString(), 
            username: user.username 
        };
        user.activityLog.push(currentActivity);

        await saveUser(user);

        res.status(200).json({ success: true, message: 'Product added to cart', cart: result.cart });
    } catch (error) {
        console.error('Error updating cart:', error);
        res.status(500).json({ success: false, message: 'Failed to update cart' });
    }
});

router.post('/api/cart/remove', isAuthorized, async (req, res) => {
    try {
        const { productId, size } = req.body;
        const user = req.user;

        const updatedCart = removeFromCart(user, productId, size);
        await saveUser(user);

        res.status(200).json({ success: true, cart: updatedCart });
    } catch (error) {
        console.error('Error removing item from cart:', error);
        res.status(500).json({ success: false, message: 'Failed to update cart' });
    }
});

router.get('/cart', async (req, res) => {
    const user = await findUserByUsername(req.cookies.username); // Fetch user data

    if (user && user.cart) {
        const populatedCart = await populateCartData(user.cart);
        res.render('cart', { cart: populatedCart });
    } else {
        res.render('cart', { cart: [] });
    }
});

router.post('/api/cart/purchase', isAuthorized, async (req, res) => {
    try {
        const user = req.user;

        const populatedPurchases = await populatePurchases(user.cart);

        user.purchaseHistory = user.purchaseHistory.concat(populatedPurchases);

        user.cart = [];

        await saveUser(user);

        res.cookie('purchaseCompleted', 'true', { httpOnly: true, maxAge: 60000 }); // Set a cookie valid for 1 minute

        res.status(200).json({ success: true, message: 'Purchase completed successfully', purchaseHistory: user.purchaseHistory });
    } catch (error) {
        console.error('Error finalizing purchase:', error);
        res.status(500).json({ success: false, message: 'Failed to complete purchase' });
    }
});

module.exports = router;

___________________________________________________________________________
document.addEventListener('DOMContentLoaded', async () => {
    const cartItemsContainer = document.getElementById('cartItems');
    const cartTotalContainer = document.getElementById('cartTotal');
    const paymentForm = document.getElementById('paymentForm');

    if (!cartItemsContainer || !cartTotalContainer || !paymentForm) {
        return;
    }

    // Fetch cart data from cookies
    const cart = loadCartFromCookies();

    // Fetch product details from the database
    const productDetails = await Promise.all(cart.map(item => fetchProductById(item.productId)));

    // Function to display cart items and total price
    function displayCartItems() {
        cartItemsContainer.innerHTML = ''; // Clear previous cart items
        let totalPrice = 0;
        cart.forEach((item, index) => {
            // Fetch the corresponding product detail
            const productDetail = productDetails[index];
            const itemPrice = item.price !== undefined ? item.price : 0;
            totalPrice += itemPrice * item.quantity;

            const cartItem = document.createElement('div');
            cartItem.className = 'cart-item';
            cartItem.innerHTML = `
            `;
            cartItemsContainer.appendChild(cartItem);
        });

        cartTotalContainer.innerHTML = `<p class="cart-total">Total Price: ${totalPrice.toFixed(2)}$</p>`;
        attachEventListeners(); // Attach event listeners after elements are rendered
    }

    // Fetch product details by ID
    async function fetchProductById(productId) {
        try {
            const response = await fetch(`/api/products/${productId}`);
            if (!response.ok) {
                throw new Error('Failed to fetch product details');
            }
            return await response.json();
        } catch (error) {
            console.error('Error fetching product details:', error);
            return null; // Return null if there's an error
        }
    }

    // Function to attach event listeners for buttons
    function attachEventListeners() {
        document.querySelectorAll('.increase-quantity').forEach(button => {
            button.addEventListener('click', function () {
                const index = this.getAttribute('data-index');
                increaseQuantity(index);
            });
        });

        document.querySelectorAll('.decrease-quantity').forEach(button => {
            button.addEventListener('click', function () {
                const index = this.getAttribute('data-index');
                decreaseQuantity(index);
            });
        });

        document.querySelectorAll('.cart-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', updateTotalPrice);
        });

        // Handle form submission
        paymentForm.addEventListener('submit', async function (event) {
            event.preventDefault(); // Prevent default form submission
        
            // Check if all fields are filled
            if (!paymentForm.checkValidity()) {
                alert('Please fill in all the payment details.');
                return;
            }

            try {
                // Send a request to finalize the purchase and update purchase history
                const response = await fetch('/api/cart/purchase', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    // Redirect to the thank you page if the purchase is successful
                    window.location.href = 'thankYou.html';
                } else {
                    // Handle failure case (e.g., insufficient stock)
                    alert(result.message || 'Failed to complete the purchase.');
                }
            } catch (error) {
                console.error('Error during purchase process:', error);
                alert('An unexpected error occurred. Please try again.');
            }
        });
    }

    // Increase quantity function
    async function increaseQuantity(index) {
        const item = cart[index];
        const response = await updateCartInBackend(item.productId, item.size, 1); // Increment by 1
    
        if (response.success) {
            cart[index].quantity += 1;
            saveCartToCookies(cart);
            displayCartItems();
        } else {
            console.error('Failed to increase quantity:', response.message);
        }
    }

    // Decrease quantity function
    async function decreaseQuantity(index) {
        const item = cart[index];
        const response = await updateCartInBackend(item.productId, item.size, -1); // Decrement by 1
    
        if (response.success) {
            if (cart[index].quantity > 1) {
                cart[index].quantity -= 1;
            } else {
                cart.splice(index, 1); // Remove the item if quantity is zero
            }
            saveCartToCookies(cart);
            displayCartItems();
        } else {
            console.error('Failed to decrease quantity:', response.message);
        }
    }

    // Update total price
    function updateTotalPrice() {
        let totalPrice = 0;
        document.querySelectorAll('.cart-checkbox:checked').forEach(checkbox => {
            const index = checkbox.getAttribute('data-index');
            totalPrice += cart[index].price * cart[index].quantity;
        });
        cartTotalContainer.innerHTML = >Total Price: $${totalPrice.toFixed(2)}</p>`;
    }

    // Display the cart items on page load
    displayCartItems();
});

// Function to get cookie by name
function getCookie(name) {
    const encodedName = encodeURIComponent(name) + "=";
    const cookieArray = document.cookie.split(';');

    for (let cookie of cookieArray) {
        cookie = cookie.trim();
        if (cookie.indexOf(encodedName) === 0) {
            const cookieValue = cookie.substring(encodedName.length, cookie.length);
            return decodeURIComponent(cookieValue);
        }
    }
    return null;
}

async function updateCartInBackend(productId, size, quantityChange) {
    try {
        const response = await fetch('/api/cart/update', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                productId: productId,
                size: size,
                quantity: quantityChange
            })
        });

        const result = await response.json();

        if (!result.success) {
            alert(result.message); // Alert the user about the insufficient stock
        }

        return result;
    } catch (error) {
        console.error('Error updating cart in backend:', error);
        return { success: false, message: error.message };
    }
}

// Function to load the cart from cookies
function loadCartFromCookies() {
    const cartData = getCookie('cart');
    if (cartData) {
        try {
            return JSON.parse(cartData);
        } catch (error) {
            console.error("Error parsing cart data:", error);
        }
    }
    return [];
}

// Function to save the cart to cookies
function saveCartToCookies(cart) {
    document.cookie = `cart=${encodeURIComponent(JSON.stringify(cart))}; path=/;`;
}

___________________________________________________________________________

document.addEventListener('DOMContentLoaded', async () => {
    const paymentForm = document.getElementById('paymentForm');

    // Handle form submission
    paymentForm.addEventListener('submit', async function (event) {
        event.preventDefault(); // Prevent default form submission

        // Check if all fields are filled
        if (!paymentForm.checkValidity()) {
            alert('Please fill in all the payment details.');
            return;
        }

        try {
            // Send a request to finalize the purchase and update purchase history
            const response = await fetch('/api/cart/purchase', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            const result = await response.json();

            if (response.ok && result.success) {
                // Redirect to the thank you page if the purchase is successful
                window.location.href = 'thankYou.html';
            } else {
                // Handle failure case (e.g., insufficient stock)
                alert(result.message || 'Failed to complete the purchase.');
            }
        } catch (error) {
            console.error('Error during purchase process:', error);
            alert('An unexpected error occurred. Please try again.');
        }
    });
});
___________________________________________________________________________
const saveUser = async (user) => {
    // Determine if the username has changed
    const existingUser = loadUserFromFile(user.oldUsername || user.username);

    if (existingUser) {
        // Check if the email is already used by another user in MongoDB
        const emailExists = await findUserByUsernameOrEmail(null, user.email);
        if (emailExists && emailExists._id.toString() !== user._id.toString()) {
            throw new Error('Email already in use.');
        }

        // If the username has changed, delete the old file
        const oldFilePath = getUserFilePath(existingUser.username);
        const newFilePath = getUserFilePath(user.username);

        if (oldFilePath !== newFilePath && fs.existsSync(oldFilePath)) {
            fs.unlinkSync(oldFilePath); // Delete the old file
        }
    }

    // Save the updated user data to MongoDB first
    const savedUser = await saveUserToMongoDB(user);

    // If MongoDB save is successful, then update the file system
    saveUserToFile(savedUser);
};

___________________________________________________________________________
router.put('/api/update-profile', async (req, res) => {
    const { oldUsername, newUsername, newEmail, address, phoneNumber } = req.body;

    try {
        const user = await findUserByUsername(oldUsername);
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        // Validate username and email
        if (!validateUsername(newUsername)) {
            return res.status(400).json({ message: 'Username must be 5-20 characters long, contain only letters, numbers, and underscores, and cannot have consecutive underscores.' });
        }

        if (!validateEmail(newEmail)) {
            return res.status(400).json({ message: 'Invalid email format.' });
        }

        if (oldUsername !== newUsername) {
            const existingUser = await isUsernameTaken(newUsername);
            if (existingUser) {
                return res.status(400).json({ message: 'Username already exists' });
            }
        }

        // Validate email isn't already in use
        const emailExists = await findUserByUsernameOrEmail(null, newEmail);
        if (emailExists && emailExists._id.toString() !== user._id.toString()) {
            return res.status(400).json({ message: 'Email already in use' });
        }

        user.username = newUsername;
        user.email = newEmail;
        user.address = address;
        user.phoneNumber = phoneNumber;

        // Include oldUsername to trigger file deletion if needed
        await saveUser({ ...user, oldUsername });

        res.status(200).json({ message: 'Profile updated successfully' });
    } catch (error) {
        console.error('Error updating profile:', error); // Add this for better error logging
        res.status(500).json({ message: 'Server error updating profile', error: error.message }); // Return more information
    }
});

___________________________________________________________________________
router.put('/api/update-profile', async (req, res) => {
    const { oldUsername, newUsername, newEmail, address, phoneNumber } = req.body;

    try {
        const user = await findUserByUsername(oldUsername);
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        // Validate email
        if (!validateEmail(newEmail)) {
            return res.status(400).json({ message: 'Invalid email format.' });
        }

        const existingEmailUser = await findUserByUsername(newEmail);
        if (existingEmailUser && existingEmailUser.username !== oldUsername) {
            return res.status(400).json({ message: 'Email already in use' });
        }

        // Proceed to update MongoDB and system file
        user.username = newUsername;
        user.email = newEmail;
        user.address = address;
        user.phoneNumber = phoneNumber;

        // Attempt to save to MongoDB
        console.log('Saving user to MongoDB...');
        await saveUser({ ...user, oldUsername });
        console.log('User saved successfully to MongoDB.');

        res.status(200).json({ message: 'Profile updated successfully' });
    } catch (error) {
        console.error('Error updating profile:', error);
        res.status(500).json({ message: 'Server error updating profile' });
    }
});

___________________________________________________________________________

router.put('/api/update-profile', async (req, res) => {
    const { oldUsername, newUsername, newEmail, address, phoneNumber } = req.body;

    try {
        const user = await findUserByUsername(oldUsername);
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        // Validate username
        if (!validateUsername(newUsername)) {
            return res.status(400).json({ message: 'Username must be 5-20 characters long, contain only letters, numbers, and underscores, and cannot have consecutive underscores.' });
        }

        // Validate email
        if (!validateEmail(newEmail)) {
            return res.status(400).json({ message: 'Invalid email format.' });
        }

        // Check if the new email is already in use by another user
        if (oldUsername !== newUsername || user.email !== newEmail) {
            const existingEmailUser = await findUserByUsername(newEmail);
            if (existingEmailUser && existingEmailUser.username !== oldUsername) {
                return res.status(400).json({ message: 'Email already in use' });
            }
        }

        if (oldUsername !== newUsername) {
            const existingUser = await isUsernameTaken(newUsername);
            if (existingUser) {
                return res.status(400).json({ message: 'Username already exists' });
            }
        }

        user.username = newUsername;
        user.email = newEmail;
        user.address = address;
        user.phoneNumber = phoneNumber;

        // Include oldUsername to trigger file deletion if needed
        await saveUser({ ...user, oldUsername });

        res.status(200).json({ message: 'Profile updated successfully' });
    } catch (error) {
        console.error('Error updating profile:', error);
        res.status(500).json({ message: 'Server error updating profile' });
    }
});

___________________________________________________________________________
const findReviews = async (query) => {
    try {
        const reviews = await Review.find(query).lean();
        return Array.isArray(reviews) ? reviews : []; // Ensure an array is returned
    } catch (error) {
        console.error('Error finding reviews:', error);
        throw error;
    }
};

___________________________________________________________________________
.review-thank-you {
    background-color: #e0f7fa;
    color: #00796b;
    padding: 10px 15px;
    margin-top: 10px;
    border: 1px solid #00796b;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    font-weight: bold;
    text-align: center;
}

.review-thank-you i {
    margin-right: 8px;
    color: #00796b;
    font-size: 20px;
}

___________________________________________________________________________
document.addEventListener('DOMContentLoaded', () => {
    const logoutButton = document.getElementById('logoutButton');
    if (logoutButton) {
        logoutButton.addEventListener('click', function (event) {
            event.preventDefault();

            fetch('/logout', {
                method: 'GET',
            })
            .then(response => {
                if (response.redirected) {
                    window.location.href = response.url;
                }
            })
            .catch(error => {
                console.error('Error during logout:', error);
            });
        });
    } else {
        console.warn('Logout button not found!');
    }

    const purchaseHistoryContainer = document.getElementById('purchaseHistory');

    // Fetch the purchase history from the server
    fetch('/api/purchase-history')
        .then(response => response.json())
        .then(purchaseHistory => {
            if (purchaseHistory.length > 0) {
                purchaseHistory.forEach(purchase => {
                    const purchaseItem = document.createElement('div');
                    purchaseItem.className = 'purchase-item';
                    purchaseItem.innerHTML = `
                            <h3>${purchase.name}</h3>
                            <p>Order Number: ${purchase._id}</p>
                            <p>Date: ${new Date(purchase.purchaseDate).toLocaleDateString()}</p>
                            <p>Price: $${purchase.price}</p>
                            <p>Quantity: ${purchase.quantity}</p>
                        </div>
                    `;

                    // Check if the order has already been reviewed
                    if (getCookie(`reviewed_${purchase._id}`)) {
                        const thankYouMessage = document.createElement('div');
                        thankYouMessage.className = 'review-thank-you';
                        thankYouMessage.innerHTML = `
                            <p><i class="fas fa-check-circle"></i> Thank you for your review!</p>
                        `;
                        purchaseItem.appendChild(thankYouMessage);
                    } else {
                        const reviewButton = document.createElement('button');
                        reviewButton.className = 'leave-review-button';
                        reviewButton.innerText = 'Leave a Review';
                        reviewButton.addEventListener('click', () => {
                            // Set cookies for product and order details
                            setCookie('productTitle', purchase.name, 1);
                            setCookie('productImage', purchase.image, 1);
                            setCookie('productId', purchase.productId, 1); // Assuming productId is available in purchase object
                            setCookie('orderNumber', purchase._id, 1); // Set the order number in a cookie
                            window.location.href = 'review.html';
                        });
                        purchaseItem.appendChild(reviewButton);
                    }

                    purchaseHistoryContainer.appendChild(purchaseItem);
                });
            } else {
                purchaseHistoryContainer.innerHTML = '<p>No purchase history found.</p>';
            }
        })
        .catch(error => {
            console.error('Error fetching purchase history:', error);
            purchaseHistoryContainer.innerHTML = '<p>Error loading purchase history.</p>';
        });

    // Function to get cookie
    function getCookie(name) {
        const nameEQ = encodeURIComponent(name) + "=";
        const ca = document.cookie.split(';');
        for(let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) === ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) === 0) return decodeURIComponent(c.substring(nameEQ.length, c.length));
        }
        return null;
    }

    // Function to set cookie
    function setCookie(name, value, days) {
        const d = new Date();
        d.setTime(d.getTime() + (days * 24 * 60 * 60 * 1000));
        const expires = "expires=" + d.toUTCString();
        document.cookie = `${name}=${value};${expires};path=/`;
    }
});

___________________________________________________________________________

document.addEventListener('DOMContentLoaded', () => {
    const logoutButton = document.getElementById('logoutButton');
    if (logoutButton) {
        logoutButton.addEventListener('click', function (event) {
            event.preventDefault();

            fetch('/logout', {
                method: 'GET',
            })
            .then(response => {
                if (response.redirected) {
                    window.location.href = response.url;
                }
            })
            .catch(error => {
                console.error('Error during logout:', error);
            });
        });
    } else {
        console.warn('Logout button not found!');
    }

    const purchaseHistoryContainer = document.getElementById('purchaseHistory');

    // Fetch the purchase history from the server
    fetch('/api/purchase-history')
        .then(response => response.json())
        .then(purchaseHistory => {
            if (purchaseHistory.length > 0) {
                purchaseHistory.forEach(purchase => {
                    const purchaseItem = document.createElement('div');
                    purchaseItem.className = 'purchase-item';
                    purchaseItem.innerHTML = `
                            <h3>${purchase.name}</h3>
                            <p>Order Number: ${purchase._id}</p>
                            <p>Date: ${new Date(purchase.purchaseDate).toLocaleDateString()}</p>
                            <p>Price: $${purchase.price}</p>
                            <p>Quantity: ${purchase.quantity}</p>
                    `;

                    // Check if the order has already been reviewed
                    if (getCookie(`reviewed_${purchase._id}`)) {
                        purchaseItem.innerHTML += `<p class="review-thank-you">Thank you for your review!</p>`;
                    } else {
                        const reviewButton = document.createElement('button');
                        reviewButton.className = 'leave-review-button';
                        reviewButton.innerText = 'Leave a Review';
                        reviewButton.addEventListener('click', () => {
                            // Set cookies for product and order details
                            setCookie('productTitle', purchase.name, 1);
                            setCookie('productImage', purchase.image, 1);
                            setCookie('productId', purchase.productId, 1); // Assuming productId is available in purchase object
                            setCookie('orderNumber', purchase._id, 1); // Set the order number in a cookie
                            window.location.href = 'review.html';
                        });
                        purchaseItem.appendChild(reviewButton);
                    }

                    purchaseHistoryContainer.appendChild(purchaseItem);
                });
            } else {
                purchaseHistoryContainer.innerHTML = '<p>No purchase history found.</p>';
            }
        })
        .catch(error => {
            console.error('Error fetching purchase history:', error);
            purchaseHistoryContainer.innerHTML = '<p>Error loading purchase history.</p>';
        });

    // Function to get cookie
    function getCookie(name) {
        const nameEQ = encodeURIComponent(name) + "=";
        const ca = document.cookie.split(';');
        for(let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) === ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) === 0) return decodeURIComponent(c.substring(nameEQ.length, c.length));
        }
        return null;
    }

    // Function to set cookie
    function setCookie(name, value, days) {
        const d = new Date();
        d.setTime(d.getTime() + (days * 24 * 60 * 60 * 1000));
        const expires = "expires=" + d.toUTCString();
        document.cookie = `${name}=${value};${expires};path=/`;
    }
});

___________________________________________________________________________
const express = require('express');
const path = require('path');
const {
    findUserById,
    saveUser,
    updateOrAddToCart,
    removeFromCart,
    populatePurchases
} = require('../utils/persist'); // Adjust the path as needed

const router = express.Router();

// Middleware to check if the user is authorized
async function isAuthorized(req, res, next) {
    const { userId, username } = req.cookies;
    if (userId && username) {
        const user = await findUserById(userId);
        if (user && user.username === username) {
            req.user = user;
            return next();
        }
    }
    res.status(401).json({ message: 'Unauthorized' });
}

// Update cart
router.post('/api/cart/update', isAuthorized, async (req, res) => {
    try {
        const { productId, size, quantity } = req.body;
        const user = req.user;

        // Call the updated updateOrAddToCart function
        const { cart, message } = await updateOrAddToCart(user, productId, size, quantity);
        await saveUser(user);

        res.json({ success: true, message: message || 'Cart updated successfully', cart });
    } catch (error) {
        console.error('Cart update error:', error);
        res.status(500).json({ success: false, message: 'Failed to update cart' });
    }
});

// Add a product to the cart
router.post('/api/cart/add', isAuthorized, async (req, res) => {
    try {
        const { productId, size, quantity } = req.body;
        const user = req.user;

        // Call the updated updateOrAddToCart function
        const { cart, message } = await updateOrAddToCart(user, productId, size, quantity);

        // Log the add-to-cart activity
        const currentActivity = { 
            type: 'add-to-cart', 
            datetime: new Date().toISOString(), 
            username: user.username 
        };
        user.activityLog.push(currentActivity);

        await saveUser(user);

        res.status(200).json({ success: true, message: message || 'Product added to cart', cart });
    } catch (error) {
        console.error('Error updating cart:', error);
        res.status(500).json({ success: false, message: 'Failed to update cart' });
    }
});

// Remove a product from the cart or decrease quantity by one
router.post('/api/cart/remove', isAuthorized, async (req, res) => {
    try {
        const { productId, size } = req.body;
        const user = req.user;

        const updatedCart = removeFromCart(user, productId, size);
        await saveUser(user);

        res.status(200).json({ success: true, cart: updatedCart });
    } catch (error) {
        console.error('Error removing item from cart:', error);
        res.status(500).json({ success: false, message: 'Failed to update cart' });
    }
});

// Serve the cart.html page
router.get('/cart', async (req, res) => {
    const user = await findUserByUsername(req.cookies.username); // Fetch user data

    if (user && user.cart) {
        const populatedCart = await populateCartData(user.cart);
        res.render('cart', { cart: populatedCart });
    } else {
        res.render('cart', { cart: [] });
    }
});

// Finalize purchase and update purchase history
router.post('/api/cart/purchase', isAuthorized, async (req, res) => {
    try {
        const user = req.user;

        // Populate purchases with detailed product information
        const populatedPurchases = await populatePurchases(user.cart);

        // Add populated purchases to the user's purchase history
        user.purchaseHistory = user.purchaseHistory.concat(populatedPurchases);

        // Clear the cart after purchase
        user.cart = [];

        // Save the updated user data to MongoDB and the file system
        await saveUser(user);

        res.status(200).json({ success: true, message: 'Purchase completed successfully', purchaseHistory: user.purchaseHistory });
    } catch (error) {
        console.error('Error finalizing purchase:', error);
        res.status(500).json({ success: false, message: 'Failed to complete purchase' });
    }
});

module.exports = router;

___________________________________________________________________________

const findProducts = async (query) => {
    try {
        const { search, maxPrice, categories, brand, size, sortByRating, sortByPrice } = query;
        const queryObj = {};

        if (search) {
            queryObj.$or = [
                { brand: new RegExp(search, 'i') },
                { model: new RegExp(search, 'i') },
                { description: new RegExp(search, 'i') }
            ];
        }

        if (maxPrice) {
            queryObj.price = { $lte: parseFloat(maxPrice) };
        }

        if (categories) {
            const categoryArray = categories.split(',').map(category => category.trim());
            queryObj.categories = { $all: categoryArray };
        }

        if (brand) {
            queryObj.brand = brand;
        }

        if (size) {
            // Ensure the size is available and in stock
            queryObj.sizes = { $elemMatch: { size: size, amount: { $gt: 0 } } };
        }

        let products = await Product.find(queryObj).lean();

        // Aggregate ratings
        const productIds = products.map(product => product._id);
        const ratings = await Review.aggregate([
            { $match: { productId: { $in: productIds } } },
            {
                $group: {
                    _id: '$productId',
                    averageRating: { $avg: '$overallRating' }
                }
            }
        ]);

        const ratingMap = new Map(ratings.map(rating => [rating._id.toString(), rating.averageRating]));
        products.forEach(product => {
            product.averageRating = ratingMap.get(product._id.toString()) || 0;
        });

        // Implement sorting
        products.sort((a, b) => {
            if (sortByRating) {
                if (sortByRating === 'desc') {
                    return b.averageRating - a.averageRating;
                } else {
                    return a.averageRating - b.averageRating;
                }
            }

            if (sortByPrice) {
                if (sortByPrice === 'desc') {
                    return b.price - a.price;
                } else {
                    return a.price - b.price;
                }
            }
        });

        return products;
    } catch (error) {
        console.error('Error finding products:', error);
        throw error;
    }
};

___________________________________________________________________________
const express = require('express');
const mongoose = require('mongoose');
const bodyParser = require('body-parser');
const cookieParser = require('cookie-parser');
const mainPageRouter = require('./routes/mainPageRouter'); // Path to your router

const PORT = process.env.PORT || 3000;
const app = express();

app.use(bodyParser.json());
app.use(cookieParser());

app.use('/', mainPageRouter);

mongoose.connect('mongodb://127.0.0.1:27017/yourDatabaseName', {
    useNewUrlParser: true,
    useUnifiedTopology: true,
})
    .then(() => {
        console.log('MongoDB connected...');
        app.listen(PORT, () => {
            console.log(`Server running on port ${PORT}`);
        });
    })
    .catch(err => console.log(err));


___________________________________________________________________________
// In utils/persist.js
const fs = require('fs');
const path = require('path');
const Product = require('../models/Product'); // Assuming you want to load product data
const USER_DATA_DIR = path.join(__dirname, '../userData'); // Or any other directory you use for data storage

const loadInitialDataFromDisk = async () => {
    try {
        const files = fs.readdirSync(USER_DATA_DIR);
        for (const file of files) {
            const filePath = path.join(USER_DATA_DIR, file);
            const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));

            // Here you can choose what to do with the data, e.g., load it into MongoDB
            // Assuming the data is related to products:
            const existingProduct = await Product.findOne({ brand: data.brand, model: data.model });
            if (!existingProduct) {
                const newProduct = new Product(data);
                await newProduct.save();
            }
        }
        console.log('Data loaded from disk successfully.');
    } catch (error) {
        console.error('Error loading data from disk:', error);
        throw error;
    }
};

module.exports = {
    loadProducts,
    createAdminUser,
    loadInitialDataFromDisk, // Export the new function
};


___________________________________________________________________________

// Registration route
registerRouter.post('/register', async (req, res) => {
    const { username, password, email } = req.body;

    // Validation steps...

    try {
        // Check if the username or email already exists
        const existingUser = await findUserByUsernameOrEmail(username, email);
        if (existingUser) {
            if (existingUser.username === username) {
                return res.status(400).json({ message: 'Username already exists' });
            }
            if (existingUser.email === email) {
                return res.status(400).json({ message: 'Email already exists' });
            }
        }

        // Hash the password before saving
        const hashedPassword = await hashPassword(password);

        // Create and save the new user to both file system and MongoDB
        await createUser(username, hashedPassword, email);

        res.status(200).json({ message: 'Registration successful' });
    } catch (error) {
        console.error('Error during registration:', error);
        res.status(500).json({ message: 'Server error during registration' });
    }
});

___________________________________________________________________________

document.addEventListener('DOMContentLoaded', function () {
    const loginForm = document.getElementById('login-form');

    loginForm.addEventListener('submit', async function (e) {
        e.preventDefault();
        const formData = new FormData(loginForm);
        const data = Object.fromEntries(formData.entries());

        try {
            const response = await fetch('/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });

            const result = await response.json();

            if (!response.ok) {
                console.error('Login failed:', result);
                alert(result.message || 'Login failed. Please try again.');
                return;
            }

            if (result.message) {
                alert(result.message);
                // Redirect or update UI as needed
            } else {
                alert('Login successful!');
                // Redirect to a different page or update UI as needed
            }
        } catch (error) {
            alert('An error occurred. Please try again.');
            console.error('Login error:', error);
        }
    });
});

___________________________________________________________________________

const express = require('express');
const bcrypt = require('bcryptjs');
const User = require('../models/User.js');

const loginRouter = express.Router();

loginRouter.post('/login', async (req, res) => {
    const { username, password } = req.body;

    try {
        const user = await User.findOne({ username });
        if (!user) {
            return res.status(400).json({ message: 'Username does not exist.' });
        }

        const isMatch = await bcrypt.compare(password, user.password);
        if (!isMatch) {
            return res.status(400).json({ message: 'Invalid password.' });
        }

        // Successful login
        res.status(200).json({ message: 'Login successful.' });
    } catch (error) {
        console.error('Error during login:', error);
        res.status(500).json({ message: 'Server error during login.' });
    }
});

module.exports = loginRouter;

___________________________________________________________________________
app.get('/api/purchase-history', async (req, res) => {
    const { userId, username } = req.cookies;

    if (!userId || !username) {
        return res.status(401).json({ message: 'Unauthorized' });
    }

    try {
        // Find the user in the database
        const user = await User.findById(userId).select('purchaseHistory');
        if (!user || user.username !== username) {
            return res.status(404).json({ message: 'User not found' });
        }

        res.status(200).json(user.purchaseHistory);
    } catch (error) {
        console.error('Error fetching purchase history:', error);
        res.status(500).json({ message: 'Server error fetching purchase history' });
    }
});


___________________________________________________________________________

import express from 'express';
import mongoose from 'mongoose';
import bodyParser from 'body-parser';
import bcrypt from 'bcryptjs';
import cookieParser from 'cookie-parser';
import crypto from 'crypto';
import fs from 'fs';
import path from 'path';
import User from './models/User.js';
import Product from './models/Product.js';
import Review from './models/Review.js';
import securityMiddleware from './middleware/security.js';

const app = express();
const PORT = process.env.PORT || 3000;

securityMiddleware(app);
__________________________________________________________________________

and so on ...




                    </code></pre>
                </div>
                

            </code></pre>
        </div>
    </div>
    
    <script src="../js/main.js"></script> <!-- path to the main.js file -->
</body>
</html>
